"use strict";
/*
 * @adonisjs/bodyparser
 *
 * (c) Harminder Virk <virk@adonisjs.com>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getFileType = exports.supportMagicFileTypes = void 0;
/// <reference path="../adonis-typings/bodyparser.ts" />
const path_1 = require("path");
const file_type_1 = require("file-type");
const media_typer_1 = __importDefault(require("media-typer"));
/**
 * We can detect file types for these files using the magic
 * number
 */
exports.supportMagicFileTypes = [
    'jpg',
    'png',
    'apng',
    'gif',
    'webp',
    'flif',
    'cr2',
    'cr3',
    'orf',
    'arw',
    'dng',
    'nef',
    'rw2',
    'raf',
    'tif',
    'bmp',
    'icns',
    'jxr',
    'psd',
    'indd',
    'zip',
    'tar',
    'rar',
    'gz',
    'bz2',
    '7z',
    'dmg',
    'mp4',
    'mid',
    'mkv',
    'webm',
    'mov',
    'avi',
    'mpg',
    'mp1',
    'mp2',
    'mp3',
    'ogg',
    'ogv',
    'ogm',
    'oga',
    'spx',
    'ogx',
    'opus',
    'flac',
    'wav',
    'qcp',
    'amr',
    'pdf',
    'epub',
    'mobi',
    'exe',
    'swf',
    'rtf',
    'woff',
    'woff2',
    'eot',
    'ttf',
    'otf',
    'ico',
    'flv',
    'ps',
    'xz',
    'sqlite',
    'nes',
    'crx',
    'xpi',
    'cab',
    'deb',
    'ar',
    'rpm',
    'Z',
    'lz',
    'cfb',
    'mxf',
    'mts',
    'wasm',
    'blend',
    'bpg',
    'docx',
    'pptx',
    'xlsx',
    'jp2',
    'jpm',
    'jpx',
    'mj2',
    'aif',
    'odt',
    'ods',
    'odp',
    'xml',
    'heic',
    'cur',
    'ktx',
    'ape',
    'wv',
    'asf',
    'dcm',
    'mpc',
    'ics',
    'glb',
    'pcap',
    'dsf',
    'lnk',
    'alias',
    'voc',
    'ac3',
    '3gp',
    '3g2',
    'm4v',
    'm4p',
    'm4a',
    'm4b',
    'f4v',
    'f4p',
    'f4a',
    'f4b',
    'mie',
    'shp',
    'arrow',
    'aac',
    'it',
    's3m',
    'xm',
    'ai',
    'skp',
    'avif',
    'eps',
    'lzh',
    'pgp',
    'asar',
    'stl',
];
/**
 * Attempts to parse the file mime type using the file magic number
 */
function parseMimeType(mime) {
    try {
        const { type, subtype } = media_typer_1.default.parse(mime);
        return { type, subtype };
    }
    catch (error) {
        return null;
    }
}
/**
 * Returns the file `type`, `subtype` and `extension`.
 */
async function getFileType(fileContents, clientName, headers, force = false) {
    /**
     * Attempt to detect file type from it's content
     */
    const magicType = await (0, file_type_1.fromBuffer)(fileContents);
    if (magicType) {
        return Object.assign({ ext: magicType.ext }, parseMimeType(magicType.mime));
    }
    /**
     * If we are unable to pull the file magicType and the current
     * bytes of the content is under the minimumBytes required,
     * then we should return `null` and force the consumer
     * to re-call this method after receiving more content
     * from the stream
     */
    if (!force) {
        return null;
    }
    /**
     * Otherwise fallback to file extension from it's client name
     * and pull type/subtype from the headers content type.
     */
    return Object.assign({ ext: (0, path_1.extname)(clientName).replace(/^\./, '') }, parseMimeType(headers['content-type']));
}
exports.getFileType = getFileType;
