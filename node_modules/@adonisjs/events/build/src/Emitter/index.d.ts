/// <reference path="../../adonis-typings/events.d.ts" />
import { ApplicationContract } from '@ioc:Adonis/Core/Application';
import { AnyHandler, EventsList, TrapHandler, EventHandler, DataForEvent, ErrorHandler, TrapAllHandler, EmitterContract, EmitterTransportContract } from '@ioc:Adonis/Core/Event';
/**
 * Emitter class exposes the API for async event emitter built on top of
 * Emittery. It also exposes an API to pre-define the Typescript types
 * for different events.
 */
export declare class Emitter implements EmitterContract {
    transport: EmitterTransportContract;
    private iocResolver?;
    private trappingEvents;
    private traps;
    private trapAllHandler?;
    private errorHandler?;
    constructor(app?: ApplicationContract);
    /**
     * Returns reference to the IoC resolver. Do not call this method until
     * handler is not a string
     */
    private getResolver;
    /**
     * Define a custom error handler
     */
    onError(handler: ErrorHandler): this;
    /**
     * Define event handler for a given event
     */
    on<K extends keyof EventsList | string>(event: K, handler: EventHandler<DataForEvent<K>> | string): this;
    /**
     * Define event handler for a given event and to be called
     * only once.
     */
    once<K extends keyof EventsList | string>(event: K, handler: EventHandler<DataForEvent<K>> | string): this;
    /**
     * Define catch all event handler to listen for all events.
     */
    onAny(handler: AnyHandler | string): this;
    /**
     * Emit event
     */
    emit<K extends keyof EventsList | string>(event: K, data: DataForEvent<K>): Promise<any>;
    /**
     * Remove existing event listener
     */
    off<K extends keyof EventsList>(event: K | string, handler: EventHandler | string): void;
    /**
     * Remove existing event listener for catch all handler
     */
    offAny(handler: AnyHandler | string): void;
    /**
     * Remove existing event listener.
     * @alias off
     */
    clearListener<K extends keyof EventsList | string>(event: K, handler: EventHandler | string): void;
    /**
     * Clear all listeners for a given event
     */
    clearListeners<K extends keyof EventsList | string>(event: K): void;
    /**
     * Clear all listeners for all events
     */
    clearAllListeners(): void;
    /**
     * Returns count of listeners for a given event or all
     * events.
     */
    listenerCount<K extends keyof EventsList | string>(event?: K): number;
    /**
     * Returns a boolean telling if listeners count for a given
     * event or all events is greater than 0 or not.
     */
    hasListeners<K extends keyof EventsList | string>(event?: K): boolean;
    /**
     * Define custom namespace for event listeners. It is set to `App/Listeners`
     * by default.
     */
    namespace(namespace: string): this;
    /**
     * Trap event instead of emitting it
     */
    trap<K extends keyof EventsList | string>(event: K, handler: TrapHandler<DataForEvent<K>>): this;
    /**
     * Trap all events instead of emitting them
     */
    trapAll(handler: TrapAllHandler): this;
    /**
     * Restore trap
     */
    restore(): this;
}
